# MVC 모델

## MVC 모델이란?

MVC(Model-View-Controller) 모델은 애플리케이션을 세 가지 주요 컴포넌트로 분리하여 설계하는 소프트웨어 아키텍처 패턴입니다.

이 모델은 애플리케이션의 **비즈니스 로직(Model)**, **사용자 인터페이스(View)**, **사용자 입력 처리(Controller)** 를 각각 독립적으로 처리함으로써 유지 보수성과 확장성을 높이는 데 중점을 둡니다.

- **Model**: 애플리케이션의 데이터와 관련된 로직을 처리합니다.
- **View**: 사용자에게 데이터를 어떻게 표시할지에 대한 UI를 담당합니다.
- **Controller**: 사용자의 입력을 처리하고, 그에 맞는 동작을 모델과 뷰에 전달합니다.

   > **Service**
   > 
   > 컨트롤러(Controller)에서 서비스를 사용하는 것이 일반적입니다
   >
   > 비즈니스 로직을 캡슐화하여 모델을 호출하고, 여러 모델 간의 상호작용을 조정합니다. 즉, 데이터를 처리하고 필요한 연산을 수행하는 역할을 합니다.
---
## MVC 모델 전체 흐름

1. **사용자 요청**
   - 사용자가 웹 애플리케이션의 UI에서 버튼 클릭이나 폼 제출과 같은 행동을 통해 요청을 보냅니다.

2. **컨트롤러 (Controller)**
   - 요청을 수신한 컨트롤러는 어떤 동작을 수행할지 결정합니다.
   - 필요한 경우, 요청에 대한 유효성 검사나 변환을 수행합니다.
   - 해당 요청을 처리하기 위해 관련 서비스 (Service)를 호출합니다.

3. **서비스 (Service)**
   - 서비스는 비즈니스 로직을 처리하고 필요한 데이터를 모델 (Model)에서 가져옵니다.
   - 여러 모델 간의 상호작용이 필요한 경우, 여기서 조정하여 데이터를 처리합니다.
   - 처리된 결과를 컨트롤러에 반환합니다.

4. **모델 (Model)**
   - 모델은 데이터베이스와의 상호작용을 통해 데이터 작업을 수행합니다.
   - 필요한 데이터를 반환하거나, 업데이트 후의 상태를 저장합니다.

5. **컨트롤러 (재진입)**
   - 서비스로부터 받은 결과를 바탕으로 적절한 뷰 (View)를 선택합니다.
   - 필요한 데이터와 함께 뷰에 전달하여 응답을 생성합니다.

6. **뷰 (View)**
   - 뷰는 컨트롤러로부터 전달받은 데이터를 기반으로 사용자에게 결과를 표시합니다.

7. **사용자에게 응답**
   -  최종적으로 화면에 표시됩니다.

---

## 대다수 기업에서 자주 사용하는 모델

### 1. **웹 애플리케이션 개발**
   - **대부분의 기업**에서는 MVC 모델을 웹 애플리케이션 개발에 적극적으로 사용합니다. 예를 들어, **Java(Spring MVC)**, **Ruby on Rails**, **ASP.NET MVC**와 같은 프레임워크가 MVC 모델을 채택하고 있습니다. 이러한 프레임워크들은 웹 애플리케이션을 효율적으로 구축하고, 유지 보수를 쉽게 합니다.

### 2. **모바일 애플리케이션 개발**
   - 모바일 애플리케이션에서도 MVC 모델을 일부 적용합니다. 특히, iOS 개발에서 **Cocoa MVC** 패턴을 사용하고, 안드로이드에서도 비슷한 구조를 사용하여 UI와 로직을 분리합니다.

### 3. **대형 기업과 스타트업**
   - **대형 기업**에서는 이미 확립된 기술 스택에 MVC 패턴을 많이 사용합니다. 복잡한 웹 애플리케이션이나 관리 시스템에서 특히 효율적입니다.
   - **스타트업**이나 작은 기업에서는 **모던 프레임워크**(React, Angular, Vue.js 등)를 사용하면서도 여전히 MVC를 기반으로 하는 서버 사이드 로직을 채택하는 경우가 많습니다.

### 4. **백엔드 개발에서의 적용**
   - **백엔드 개발**에서는 MVC 모델이 전통적으로 많이 사용됩니다.

---
## MVC 모델의 장점

### 1. **유지보수 용이**
   - 각 컴포넌트가 독립적으로 작동하므로 하나의 요소를 수정해도 다른 부분에 미치는 영향이 적습니다. 예를 들어, UI(View)를 수정하더라도 Model이나 Controller에 영향을 미치지 않습니다.
   
### 2. **재사용성 증가**
   - Model, View, Controller는 독립적으로 구성되어 있으므로 다른 애플리케이션이나 기능에 재사용이 용이합니다. 예를 들어, 동일한 비즈니스 로직을 여러 뷰에서 사용할 수 있습니다.
   
### 3. **테스트 용이**
   - 각 구성 요소를 독립적으로 테스트할 수 있어, 디버깅과 테스트 과정에서 효율성을 높입니다. 예를 들어, Model은 데이터 처리 로직만 담당하므로 해당 부분만 집중적으로 테스트할 수 있습니다.
   
### 4. **분리된 관심사 (Separation of Concerns, SoC)**
   - 모델, 뷰, 컨트롤러가 각각 다른 역할을 하여, 관심사가 명확히 구분됩니다. 이는 코드의 가독성을 높이고, 협업이 용이하게 만듭니다.

### 5. **협업 효율성**
   - 개발자, 디자이너, 테스터 등 팀원들이 서로 다른 부분을 동시에 작업할 수 있어 개발 속도가 빨라집니다. 예를 들어, 개발자는 Model과 Controller를, 디자이너는 View를 독립적으로 작업할 수 있습니다.

### 6. **확장성**
   - 새로운 기능을 추가하거나 수정할 때 기존의 코드 구조를 변경하지 않고도 손쉽게 추가할 수 있습니다. 새로운 View나 Model을 추가하는 것이 용이합니다.

---
## MVC 모델에서 DAO에 Interface를 두는 이유

MVC(Model-View-Controller) 모델에서 DAO(Data Access Object)에 인터페이스를 주는 이유는 여러 가지가 있습니다. 

### 1. 유연성 향상
인터페이스를 사용하면 실제 구현체에 의존하지 않게 되어, 다른 데이터베이스나 저장소 시스템으로의 변경이 용이해집니다. 예를 들어, MySQL을 사용하던 애플리케이션을 Oracle로 변경해야 할 경우, DAO 인터페이스만 변경하고 그에 맞는 새로운 구현체를 제공하면 됩니다. 이를 통해 데이터베이스 구현체가 바뀌어도 애플리케이션의 나머지 부분에 미치는 영향이 최소화됩니다.

### 2. 테스트 용이성
DAO 인터페이스를 사용하면 실제 데이터베이스와의 연결 없이도 DAO를 테스트할 수 있습니다. 가짜(혹은 모의) 객체(Mock Object)를 사용하여 데이터베이스와의 의존성을 없애고, 단위 테스트를 손쉽게 할 수 있습니다. 이로 인해 테스트 코드를 작성하고 유지하는 데 드는 비용이 줄어듭니다.

### 3. 느슨한 결합
인터페이스를 사용함으로써, 애플리케이션의 다른 부분은 DAO 구현체에 대해 알 필요 없이 인터페이스를 통해 상호작용할 수 있습니다. 이는 클래스 간의 의존성을 최소화하는 데 도움을 주며, 애플리케이션의 유지 보수성을 높이고 확장성도 증가시킵니다.

### 4. 다양한 구현 제공
DAO 인터페이스를 사용하면, 특정 요구 사항에 맞는 여러 구현체를 제공할 수 있습니다. 예를 들어, 한 DAO 인터페이스에 대해, 하나는 파일 기반 데이터 저장소를, 다른 하나는 SQL 기반 데이터 저장소를 사용할 수 있습니다. 다양한 구현을 사용할 수 있다는 점에서 선택의 폭이 넓어집니다.

### 5. 디자인 패턴의 적용
DAO 인터페이스를 사용함으로써, '데이터 접근 계층'을 다른 계층과 분리하여, 보다 깔끔한 아키텍처를 구현할 수 있습니다. 이는 '데이터 접근 객체 패턴'을 구현하는 기본적인 방법이며, 코드의 재사용성과 확장성을 높이는 데 기여합니다.


---

## 서비스에 Interface를 두지 않는 이유

서비스 부분에 인터페이스를 두지 않는 경우도 있지만, 인터페이스를 두지 않는 이유에 대해 몇 가지 관점에서 설명할 수 있습니다

### 1. 간단한 구조에서 불필요할 수 있음
작은 규모의 애플리케이션이나 단순한 서비스 로직에서는 서비스에 인터페이스를 두지 않아도 충분히 효과적으로 작동할 수 있습니다. 이 경우, 서비스 클래스가 너무 간단하고 변경이 적다면, 굳이 인터페이스를 추가하는 것이 코드 복잡성만 증가시킬 수 있습니다. 따라서 작은 프로젝트나 프로토타입에서는 서비스 인터페이스 없이 구현하는 것이 더 간편할 수 있습니다.

### 2. 서비스 로직의 복잡도
서비스 로직이 매우 간단하거나, 특정 클래스에 의존하는 비즈니스 로직을 처리하는 경우에는 인터페이스가 필요하지 않다고 판단할 수 있습니다. 예를 들어, 서비스 클래스가 단일 책임만 가지고 있을 때, 굳이 인터페이스를 추가하지 않아도 충분히 유연성을 확보할 수 있습니다.

### 3. 동일한 서비스 구현체의 사용
서비스의 구현체가 고정되어 있고, 이를 변경할 필요가 없다고 판단되면 인터페이스를 두는 것보다는 서비스 클래스 자체로 충분히 역할을 할 수 있습니다. 예를 들어, 애플리케이션이 커지지 않거나, 서비스가 단일 구현체만 사용할 때에는 인터페이스를 두는 것이 오히려 불필요한 추가 작업이 될 수 있습니다.

### 4. 관습적인 이유
많은 프레임워크에서는 서비스에 인터페이스를 두지 않고 구현체만 사용하는 경우도 많습니다. 예를 들어, Spring에서는 Service 클래스 자체를 빈으로 등록할 수 있기 때문에 인터페이스가 필요 없다고 판단할 수 있습니다. 이런 경우, 구현체만으로도 충분히 의존성 주입(Dependency Injection)을 처리할 수 있습니다.

### 5. 성능 및 관리의 간소화
인터페이스를 사용하지 않으면, 코드의 양이 줄어들고 관리해야 할 코드가 단순해지기 때문에, 일부 프로젝트에서는 인터페이스를 굳이 만들지 않기로 결정할 수 있습니다. 특히, 팀 규모가 작거나 프로젝트가 급하게 진행될 때, 단순화를 추구하는 경우 인터페이스 없이 직접 구현하는 것이 선호될 수 있습니다.
