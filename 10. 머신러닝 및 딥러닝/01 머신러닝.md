# 머신러닝
---
## 환경설정

### 기싱환경
```
conda create -n pyml python=3.10
```
![image](https://github.com/user-attachments/assets/ce192c6e-cc99-49da-9f83-2b12191633c3)

![image](https://github.com/user-attachments/assets/19e305ab-8dbb-44cb-80f5-9f548f5c97b7)

```
conda activate pyml
```
![image](https://github.com/user-attachments/assets/5f9bb3db-97f7-49cd-acc2-7cfdb1697474)

```
conda install numpy==1.21.2 scipy==1.7.0 scikit-learn==1.2 matplotlib==3.4.3  pandas==1.3.2 ipykernel
```
![image](https://github.com/user-attachments/assets/97b82766-7bce-4f7c-9f21-746a2ce5d83f)

```
conda install numpy==1.21.2 scipy scikit-learn==1.2 matplotlib==3.4.3  pandas ipykernel
```
![image](https://github.com/user-attachments/assets/f68a8e55-83ca-4b9f-8867-233291d73b7c)

```
conda install numpy==1.21.2 scipy scikit-learn==1.2 matplotlib  pandas ipykernel
```
![image](https://github.com/user-attachments/assets/196d51fd-8b61-47f3-a14c-460ce582e681)

```
conda install numpy==1.23.3 scipy scikit-learn==1.2 matplotlib  pandas ipykernel
```
![image](https://github.com/user-attachments/assets/617195b8-a561-4108-bbf4-2ddeb16f5ef1)

```
pip freeze > requirements.txt
```
![image](https://github.com/user-attachments/assets/1677c9b1-0562-4e2b-b867-9523cc200f8c)

만약에 requirements.txt를 설치하고 싶으면 아래 명령어를 실행하면 된다.
```
pip install -r requirements.txt
```

---

## numpy

1. 넘파이란
   - 파이썬에서 수치 계산을 효율적으로 할 수 있도록 지원하는 라이브러리
   - 다차원 배열 객체(ndarray)를 제공
   - 벡터, 행렬 연산과 같은 고속으로 수행할 수 있도록 최적화되어 있음
   - 과학 계산, 머신러닝, 딥러닝, 데이터 분석등 다양한 분야에 사용
    
2. 특징
   - 고속 연산 지원 : c언어로 구현되어 내부 연산이 빠르다
   - 다차원 배열 지원
   - 브로드캐스팅 지원 : 서로 다른 크기의 배열 간 연산을 가능
   - 다양한 수학 함수 지원 : 선형대수, 통계, 랜덤 샘플링 등의 다양한 함수 지원
   - python 리스트보다 메모리를 효율적으로 사용

3. numpy 기본 사용법
   - 설치 : pip(conda) install numpy
   - import numpy as np

```
import numpy as np

# 주요 기능 및 예제

# 배열 생성 (np.array())
# 1차원 배열 생성
arr1 = np.array([1,2,3,4,5])

print(f'arr1 : {arr1}')

# 2차원 배열 생성
arr2 = np.array([
    [1,2,3]
    ,[4,5,6]
])
print(f'arr2 : {arr2}')

# 3차원 배열 생성

arr3 =np.array(
    [
        [
            [1,2]
            ,[3,4]
            ,[5,6]
            ,[7,8]
        ]
    ]
)
print(f'arr3 : {arr3}')
```
![image](https://github.com/user-attachments/assets/81aa6f7b-7aed-4f5c-b595-35936db79445)

```
import numpy as np

# 주요 기능 및 예제

# 배열 생성 (np.array())
# 1차원 배열 생성
arr1 = np.array([1,2,3,4,5])

# 2차원 배열 생성
arr2 = np.array([
    [1,2,3]
    ,[4,5,6]
])


# 3차원 배열 생성

arr3 =np.array(
    [
        [
            [1,2]
            ,[3,4]
            ,[5,6]
            ,[7,8]
        ]
    ]
)
print('='*50)

print(f'arr1 배열의 차원 : {arr1.ndim}')
print(f'arr2 배열의 차원 : {arr2.ndim}')
print(f'arr3 배열의 차원 : {arr3.ndim}')
print('='*50)
print(f'arr1 배열의 크기 : {arr1.shape}')
print(f'arr2 배열의 크기 : {arr2.shape}')
print(f'arr3 배열의 크기 : {arr3.shape}')

print('='*50)

print(f'arr1 배열의 원소 개수 : {arr1.size}')
print(f'arr2 배열의 원소 개수 : {arr2.size}')
print(f'arr3 배열의 원소 개수 : {arr3.size}')

print('='*50)

print(f'arr1 배열의 데이터 타입 : {arr1.dtype}')
print(f'arr2 배열의 데이터 타입 : {arr2.dtype}')
print(f'arr3 배열의 데이터 타입 : {arr3.dtype}') # ndarray는 동일타입만 저장 할 수 있다
```
![image](https://github.com/user-attachments/assets/a2760dec-fd88-4c21-8157-1a0e43b706e2)

```
import numpy as np
# 특정값을 갖는 배열 생성
# 0값을 갖는 배열 : np.zeros((행,열))
zeroes =np.zeros(
    (3,3)
)
zeroes
```
![image](https://github.com/user-attachments/assets/2613dd34-7f86-4229-a437-574730734353)

```
import numpy as np
# 특정값을 갖는 배열 생성
# 0값을 갖는 배열 : np.zeros((행,열))
zeroes_ =np.zeros(
    (3,3)
)
print(zeroes_)
print('='*50)
# 1값을 갖는 배열 : np.ones((행,열))
ones_ =np.ones(
    (3,3)
)
print(ones_)
print('='*50)
# 특정값으로 채운 배열 : np.full((행,열),특정값)

full=np.full((2,2),5)
print(full)

print('='*50)
# 연속된 숫자로 채운 배열 생성 : np.arange(start,end, stop)
arr4=np.arange(1,10,2)
print(arr4)
print('='*50)

# np.linspace(start,end,count)
lin_arr=np.linspace(0,100,5) # 0~100 사이에서 5개 값으로 생성
print(lin_arr)
```
![image](https://github.com/user-attachments/assets/dc3c08d7-c94a-49f2-a615-04af3b193942)

```
import numpy as np

# 난수 배열 생성

# numpy의 random모듈을 사용하면 다양한 난수 배열을 생성 할 수 있다.

# np.random.rand(행,열) : 0~1사이의 난수를 가진 배열 생성
np.random.seed(42) # seed에 의해 rand 값이 바뀔수도 있고 안 바뀔수도 있다

rand_arr = np.random.rand(2,3)
print(rand_arr)
```
![image](https://github.com/user-attachments/assets/947023bd-f155-4a66-94c2-24b4c223db30)

```
import numpy as np

# 난수 배열 생성

# numpy의 random모듈을 사용하면 다양한 난수 배열을 생성 할 수 있다.

# np.random.rand(행,열) : 0~1사이의 난수를 가진 배열 생성
np.random.seed(42) # seed에 의해 rand 값이 바뀔수도 있고 안 바뀔수도 있다

rand_arr = np.random.rand(2,3)
print(rand_arr)

# 정규분포를 따르는 난수 배열 생성 : np.random.randn(행,열)
randn_arr=np.random.randn(2,2)
print(randn_arr)

# 특정 범위의 정수 난수 배열 생성 : np.random.randint(start,ent,[(행,열)])
randint_arr= np.random.randint(1,10,[3,4])
print(randint_arr)
```
![image](https://github.com/user-attachments/assets/4023bd24-a25d-43ba-aec1-448a0525d54c)

```
import numpy as np

# 배열 연산(더하기, 빼기, 곱셈, 나눗셈, 제곱)
a_vector =np.array([1,2,3])
b_vector =np.array([4,5,6])
print(f'덧셈 : {a_vector+b_vector}')
print(f'뺄셈 : {a_vector-b_vector}')
print(f'곱셈 : {a_vector*b_vector}')
print(f'제곱 : {a_vector**b_vector}')
```
![image](https://github.com/user-attachments/assets/f22eca3b-8e9f-434e-a1e9-ad9237c49ba3)

```
import numpy as np

# 배열 인덱싱 및 슬라이싱
arr=np.array([
    [1,2,3]
    ,[4,5,6]
    ,[7,8,9]
])

print(f'arr : {arr}')
print(f'첫번째 행, 두번째 열 : {arr[0][1]}') # arr[행][열]
print(f'첫번째 행, 두번째 열 : {arr[0,1]}') # arr[행,열]

# 특정 행 슬라이싱
print(f'첫번째 행 : {arr[0]}')
print(f'첫번째 행 : {arr[0,]}')
print(f'첫번째 행 : {arr[0,:]}')

# 특정 열 슬라이싱
print(f'두번째 열 : {arr[:,1]}')

# 부분 배열 가져오기
print(f'2x2 부분 배열 : {arr[1:3,1:3]}')
```
![image](https://github.com/user-attachments/assets/2c63edbe-ad55-418a-9c69-91304e275994)

```
import numpy as np

# 선형대수 연산
# 선형 변환(Linear Transformation)은 벡터나 행렬을 다른 벡터나 행렬로 변환하는 수학적 과정
# 특정 방향으로 확장/축소하는 역할
A = np.array([
    [1,2]
    ,[3,4]
])
B = np.array([
    [1,1]
    ,[2,2]
])

# 점 곱 
# 주어진 데이터(A)를 가중치(B)로 선형 변환한 것이다.
dot_prod=np.dot(A,B)
print(f'행 열 곱 : {dot_prod}')
```
![image](https://github.com/user-attachments/assets/58069830-1c49-4a17-a646-3ff64da28bfe)

```
import numpy as np

# 전체 행렬 : transpose
A = np.array([
    [1,2]
    ,[3,4]
])
B = np.array([
    [1,1]
    ,[2,2]
])

A,A.T,A.transpose()
```
![image](https://github.com/user-attachments/assets/5281654f-1165-429e-804f-e53f6174cdb5)

```
import numpy as np

a=np.array([1,2,3])
print(f'a shape : {a.shape}')
b=np.array([1,2,3])
print(f'b shape : {b.shape}')
print(np.dot(a,b))
print(np.dot(a.T,b))
```
![image](https://github.com/user-attachments/assets/b1029566-640d-4b8c-ba45-49df18d822a2)

```
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]])
print(f'a shape : {a.shape}')

b = np.array([1, 2, 3])
print(f'b shape : {b.shape}')

print(np.dot(a, b))

try:
    print(np.dot(a.T, b))
except Exception as e:
    print('오류: ' + str(e))
```
![image](https://github.com/user-attachments/assets/b25cf09e-fbf0-493f-9f67-4fcb8f5795f9)

```
import numpy as np

# 역행렬
# 역행렬 존재하는 조건
# 1. 정사각 행렬(Square Matrix) (nxn)
# 2. 행렬식이 0이 아니어야한다. 행렬식이 0 이면 역행렬이 존재하지 않고 이러한 행렬을 특이행렬(Singular Matrix)라고 한다.
#    AxA-1 = A-1
#    단위 행렬(Identity Matrix), 행렬 곱셈의 항등원 역할



# 행렬식 : 정사각 행렬의 스칼라(단일값) 값을 의미한다.
# 특정 행렬(데이터)이 선형변환에서 공간을 얼마나 변환시키는지를 나타나는 값

# 행렬식이 0이면 해당 행렬이 역행렬을 가질 수 없다(det(A)=0)
# 해당 행렬이 선형 종속(Linear Dependent)이 된다

# 행렬식이 0이 아니면
# 행렬이 가역(invertible)하며, 역행렬이 존재한다.

# 역행렬과 행렬식 계산
# 1. 역행렬 구하기(np.linalg.inv())

# 행렬 A : 2X2 정사각행렬
A = np.array([
    [4,7]
    ,[2,6]
]
)

# 역행렬 구하기
A_inv = np.linalg.inv(A)

print(A_inv)

# 단위 행렬 구하기
I = np.dot(A,A_inv)
print(I)

```
![image](https://github.com/user-attachments/assets/2cea4b7d-3551-4b2a-9523-e76ff2ce5764)

```
import numpy as np
# 역행렬 존재하지 않는 행렬
B = np.array([
    [4,12]
    ,[2,6]
]
)


B_inv = np.linalg.inv(B)

print(B_inv)

B_I = np.dot(B,B_inv)
print(B_I)
```
![image](https://github.com/user-attachments/assets/daa078ff-70a9-4178-a56c-558d5be38794)

```
import numpy as np

# 행렬식 구하기 (np.linalg.det())

# 3x3 정사각 행렬
B = np.array(
    [
        [1,2,3]
        ,[4,5,6]
        ,[7,8,9]
    ]
)
print(B)

# 역행렬 구하기
B_inv = np.linalg.inv(B)
print(B_inv)

# 행렬식 구하기
B_det = np.linalg.det(B) # 행렬식 결과값은 스칼라값(단일값)이 나온다

print(B_det)
```
![image](https://github.com/user-attachments/assets/9c66ba69-f873-4048-bae0-da03d31aa9bd)

```
import numpy as np

# 행렬식 구하기 (np.linalg.det())

# 3x3 정사각 행렬
B = np.array(
    [
        [1,2,3]
        ,[4,5,6]
        ,[7,8,10]
    ]
)
print(B)

# 역행렬 구하기
B_inv = np.linalg.inv(B)
print(B_inv)

# 행렬식 구하기
B_det = np.linalg.det(B)

print(B_det)
```
![image](https://github.com/user-attachments/assets/59187ccc-4df2-480b-b304-c67ef2bfc3c4)

```
import numpy as np

# 특이 행렬(Singular Matrix)

C = np.array(
    [
        [1,2]
        ,[2,4]
    ]
)

print(C)

# 행렬식 확인
print(f'행렬식 값 : {np.linalg.det(C)}')
```
![image](https://github.com/user-attachments/assets/a2d686a9-43ea-4de7-8ece-7dcf989ac1dc)

```
import numpy as np

# 특이 행렬(Singular Matrix)

C = np.array(
    [
        [1,2]
        ,[2,4]
    ]
)

print(C)

# 행렬식 확인
print(f'행렬식 값 : {np.linalg.det(C)}')

try:
    c_inv = np.linalg.inv(C)
    print(f'역행렬 : {c_inv}')
except np.linalg.LinAlgError:
    print('역행렬을 가질 수 없는 특이 행렬이다.')

```
![image](https://github.com/user-attachments/assets/e6b68221-b6fd-4689-b3d7-84eae7dbb137)

### 역행렬의 해석과 의미

1. 역행렬의 존재 조건
- 행렬  A가 정사각 행렬이어야 한다.
- 행렬식이 0이 아니어야한다.
- 선행독립(Linear Independent)인 열벡터를 가져야 한다.
    - 즉, 행렬의 열벡터들이 서로 독립적이면 역행렬이 존재하게 된다.

2. 해석
2.1 선형변환 관점
- 행렬 A는 공간을 변형시키는 선형 변환으로 볼 수 있다.
- 역행렬은 이 변환을 되돌리는 역할을 한다.(공간을 복원하는 역할)

2.2 기하학적 관점
- 역행렬이 존재 : 변환이 가역적이라면, 좌표 공간을 다시 원래대로 복원
- 역행렬이 존재 x : 변환이 공간을 축소시키거나, 특정 차원으로 줄여 되둘리 수 없는 변환(Singular Transformation)이 된다.

### Singular Tranformation
- 역행렬이 존재하지 않는 경우는 공간을 완전히 축소시키는 변환을 의미한다.
