# Titanic: 생존자 예측 데이터처리

## Predict survival on the Titanic

- Defining the problem statement
- Collecting the data
- Exploratory data analysis
- Feature engineering
- Modelling
- Testing
---

## 타이타닉 생존여부 예측 모델
- 예측 모델 처리 순서
  - 목표 설정
  - 데이터 분석(시각화
  - 더이터 전처리
  - 모델 학습
  - 모델 성능 체크
  - 모델 성능 평가 : 성는이 떨어지면 위로 다시 돌아가야함

---
## 데이터 로드 및 기본 정보 확인
- 데이터 집합 : train.csv, test.csv
  
```
from IPython.display import Image
Image(url= 'https://static1.squarespace.com/static/5006453fe4b09ef2252ba068/5095eabce4b06cb305058603/5095eabce4b02d37bef4c24c/1352002236895/100_anniversary_titanic_sinking_by_esai8mellows-d4xbme8.jpg')
```
![image](https://github.com/user-attachments/assets/14d366f0-83a3-4aae-9c05-abfba28a30b7)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)
train_df
```
![image](https://github.com/user-attachments/assets/ae9f11f2-ffd5-48dc-9ef8-48e75484d2bc)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)
train_df.info()
```
![image](https://github.com/user-attachments/assets/503c351a-e23e-44da-abcc-907be9c4d040)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

# 데이터 크기(구조) 확인
train_df.shape
```
![image](https://github.com/user-attachments/assets/dcc47cbc-da8a-4ff4-89dc-890e201738f4)

주요 컬럼 정리
- Survived(목표 변수) : 0(사망),1(생존)
- Pclass(등급) : 1(1등석), 2(2등석), 3(3등석)
- Sex(성별) : male(남자), female(여자)
- Age(나이) : 데이터 타입 float(실수), 연속 데이터 => 범주형 변경 필요(카테고리컬 데이터)
- SibSp (형제/배우자 수) 
- Parch (부모 자식 수)
- Cabin (방이름 (NaN 값 존재))
- Fare(티켓 가격)
- Embarked(승선 항구 ) : C (Cherbourg), S(Southampton), Q(Queenstown)

```
# 탐색적 데이터 분석(EDA), 시각화
# 1. 생존자 비율 : 불균형 데이터 셋, 사용자가 60% 이상 된다.

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

plt.figure(figsize=(12,8))
sns.countplot(
    data=train_df
    , x= 'Survived'
    , palette='coolwarm'
)
plt.show()
```
![image](https://github.com/user-attachments/assets/2d6589d0-0f44-4b02-9a05-d8161d9dbd17)

```
# 탐색적 데이터 분석(EDA), 시각화

# 성별과 생존 관계
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

plt.figure(figsize=(12,8))
sns.barplot(
    data=train_df
    , x= 'Sex'
    , y='Survived'
    , palette='coolwarm'
)

plt.show()
```
![image](https://github.com/user-attachments/assets/29cc0357-7299-4ab0-b09f-6f11c1d231ea)

```
# 탐색적 데이터 분석(EDA), 시각화

# 좌석등급과 생존 관계
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

plt.figure(figsize=(12,8))
sns.barplot(
    data=train_df
    , x= 'Pclass'
    , y='Survived'
    , palette='coolwarm'
)

plt.show()
```
![image](https://github.com/user-attachments/assets/951ff844-e272-4806-a93e-e240f35eb4c0)

```
# 나이(연속데이터)와 생존 관계
# 히스토그램
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

plt.figure(figsize=(12,8))

# 생존 데이터관련성
sns.histplot(
    data=train_df
    , x= train_df[train_df['Survived']==1]['Age'] # 생존한 사람들의 나이
    , bins=30 # 30개 구간으로 나누고 밀도
    ,color='green'
    , kde=True # 곡선 표시 여부
    , label='Survived'
)

# 사망 데이터 관련성
sns.histplot(
    data=train_df
    , x= train_df[train_df['Survived']==0]['Age'] # 죽은 사람들의 나이
    , bins=30 # 30개 구간으로 나누고 밀도
    ,color='red'
    , kde=True # 곡선 표시 여부
    , label='Not Survived'
)

plt.legend()
plt.show()
```
![image](https://github.com/user-attachments/assets/e2b09370-247e-48ee-bcff-1303fe4dde5f)

> 어린이(10세이하)의 생존율이 높음
> 20대~40대의 성인 남성의 생존율이 낮음

---
## 연속된 데이터를 범주형 데이터 변환

왜 나이를 범주형 데이터로 변환하는가?
   - 연속형 데이터의 문제점
     - 나이는 0세부터 80세 이상 까지 연속 값을 가지고 있는데, 특정 연령대가 생존과 강한 연관성이 있더라도 머신러닝의 모델이 학습하기 어렵다.
     - 분류 모델들(결정 트리, 랜덤 포레스트, XGBoost 등)은 연속형 값보다 범주형 변수를 더 잘할 수 있다.
   - 범주형 데이터의 장점
     - 이상치 데이터에 의한 학습 문제 완화

### 범주화 방법
#### 1. 동간격 방법(Equal Interval) : 일정한 간격으로 나누는 방법 (10대, 20대, ....)
  - 장점 : 특정 구간에서 생존율이 비슷한지 비교가능
  - 단점 : 데이터의 분포와 상관 없이 균등하게 나누기 때문에, 특정 그룹이 너무 많거나 적을수 있다.

```

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

# 나이 구간을 5개로 나누는 방법(0~16,17~32,33~48,49~64, 65+)
# 0~16 -> 0
# 17~32 -> 1
# 33~48 -> 2
# 49~64 -> 3
# 65+ -> 4
age_bin=pd.cut(
    train_df['Age']
    , bins=[0,16,32,48,64,100]
    ,labels=[0,1,2,3,4]
)
age_bin

```
![image](https://github.com/user-attachments/assets/3f711538-1f0d-492d-a140-4b02b6c97ac7)

#### 2. 분위수 방법(Quantile Binning) : 데이터를 동등한 개수의 그룹으로 나누는 방법
  - 장점 : 각 그룹에 데이터가 균등하게 분포되도록 나누므로 데이터 불균형을 방지
  - 단점 : 나이의 의미적 구분이 불분명할 수 있다.
    
```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

age_bin=pd.qcut(
    train_df['Age']
    , q=10 # 10분기로 나누어로
    ,labels=[0,1,2,3,4,5,6,7,8,9]
)
age_bin
```
![image](https://github.com/user-attachments/assets/b1c78dba-f93d-40c8-97c4-6ce994336701)

```
# 해석
# 1사분위 : (최소~25%) : 0
# 2사분위 : (25%~50%) : 1
# 3사분위 : (50~75%) : 2
# 4사분위 : (75~최대) : 3


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

age_bin=pd.qcut(
    train_df['Age']
    , q=4 # 4분기로 나누어로
    ,labels=[0,1,2,3]
)
age_bin
```
![image](https://github.com/user-attachments/assets/809903e0-a5e8-402e-bab7-26e9670a384e)

#### 3. 의미 기간 그룹화(도메인 지식 활용) : 연령대를 실제 생존율 반환에 맞춰 직접 지정 ( 사회적으로 인식하는 방법)
  - 장점 : 실제 생존율 패턴과 관련이 있는 연령대를 구분 할 수 있음
  - 단점 : 특정 연령대로 데이터가 쏠릴 수 도 있어 성능이 다소 떨어 질 수 있다

 ```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

age_bin=train_df['Age'].apply(
    lambda x: 0 if x<=10 else
              1 if x <=20 else
              2 if x <=30 else
              3 if x <=40 else
              4 if x <=50 else
              5 if x <=60 else
              6 if x <=70 else
              7 if x <=80 else
              8
)
age_bin
```
![image](https://github.com/user-attachments/assets/5edebf8f-bff5-4907-9bf5-3bedd56bc542)

#### 결론 및 정리
1. 언제 범주형 변환을 사용할가?
   - 결정 트리기반 모델(Random Forest, XGBoost)에서는 범주형 변환이 유용할 수 있다.
   - 데이터가 비선형 관계일 경우, 연속형보다 범주형 변수가 성능이 더 좋을 수 있다.
   - 데이터가 적거나 이상치가 많을 때 범주화하면 안정적인 학습이 가능
2. 어떤 상황에서 어떤 방법이 좋을까?
   - 데이터가 층분히 많다면 분위수 변환(Qcut)이 일반적으로 성능이 좋다
   - 의미적인 구분이 필요하다면 도메인 지식 기반 그룹화가 더 직관적일 수 있다.
   - 기본적으로는 동간격 반환 후 다른 방식과 성능 비교하여 사용하는 것을 추천

---
## 데이터 종류

데이터는 크게 두 가지로 구분된다.
- 질적 데이터 (Qualitative Data , 범주형 데이터) : 수치화할 수 없는 데이터
- 양적 데이터 (Quantitive Data, 수치형 데이터) : 수치로 측정된 데이터

- 각각의 세부 유형과 특징
  - 질적데이터
    - 명목형(Nominal) 데이터 : 순서가 없는 데이터
      - 예시 : 성별, 혈액형, 국적 등
      - 분석 방법 : 빈도 분석, 카이제곱검정(범주형데이터 간의 관계를 결정)
    - 서열형(Ordinal) 데이터 : 순서가 있는 명목형 데이터
      - 예시 : 고객 만족도, 학점
      - 분석 방법 : 중앙값 분석, 순위, 상관 분석
  - 양적데이터
    - 이산형데이터(Discrete)
      - 예시 : 고객 방문 횟수(1,2,3..), 자녀수
      - 분석 방법 : 평균, 분산, 포아송분포
    - 연속형데이터(Continuous)
      - 예시 : 키, 몸무게, 온도
      - 분석 방법 : 평균, 표준편차(STD(Standard DB)), 정규분포
