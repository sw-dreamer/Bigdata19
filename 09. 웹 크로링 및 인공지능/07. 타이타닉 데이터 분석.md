# Titanic: 생존자 예측 데이터처리

## Predict survival on the Titanic

- Defining the problem statement
- Collecting the data
- Exploratory data analysis
- Feature engineering
- Modelling
- Testing
---

## 타이타닉 생존여부 예측 모델
- 예측 모델 처리 순서
  - 목표 설정
  - 데이터 분석(시각화
  - 더이터 전처리
  - 모델 학습
  - 모델 성능 체크
  - 모델 성능 평가 : 성는이 떨어지면 위로 다시 돌아가야함

---
## 데이터 로드 및 기본 정보 확인
- 데이터 집합 : train.csv, test.csv
  
```
from IPython.display import Image
Image(url= 'https://static1.squarespace.com/static/5006453fe4b09ef2252ba068/5095eabce4b06cb305058603/5095eabce4b02d37bef4c24c/1352002236895/100_anniversary_titanic_sinking_by_esai8mellows-d4xbme8.jpg')
```
![image](https://github.com/user-attachments/assets/14d366f0-83a3-4aae-9c05-abfba28a30b7)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)
train_df
```
![image](https://github.com/user-attachments/assets/ae9f11f2-ffd5-48dc-9ef8-48e75484d2bc)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)
train_df.info()
```
![image](https://github.com/user-attachments/assets/503c351a-e23e-44da-abcc-907be9c4d040)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

# 데이터 크기(구조) 확인
train_df.shape
```
![image](https://github.com/user-attachments/assets/dcc47cbc-da8a-4ff4-89dc-890e201738f4)

주요 컬럼 정리
- Survived(목표 변수) : 0(사망),1(생존)
- Pclass(등급) : 1(1등석), 2(2등석), 3(3등석)
- Sex(성별) : male(남자), female(여자)
- Age(나이) : 데이터 타입 float(실수), 연속 데이터 => 범주형 변경 필요(카테고리컬 데이터)
- SibSp (형제/배우자 수) 
- Parch (부모 자식 수)
- Cabin (방이름 (NaN 값 존재))
- Fare(티켓 가격)
- Embarked(승선 항구 ) : C (Cherbourg), S(Southampton), Q(Queenstown)

```
# 탐색적 데이터 분석(EDA), 시각화
# 1. 생존자 비율 : 불균형 데이터 셋, 사용자가 60% 이상 된다.

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

plt.figure(figsize=(12,8))
sns.countplot(
    data=train_df
    , x= 'Survived'
    , palette='coolwarm'
)
plt.show()
```
![image](https://github.com/user-attachments/assets/2d6589d0-0f44-4b02-9a05-d8161d9dbd17)

```
# 탐색적 데이터 분석(EDA), 시각화

# 성별과 생존 관계
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

plt.figure(figsize=(12,8))
sns.barplot(
    data=train_df
    , x= 'Sex'
    , y='Survived'
    , palette='coolwarm'
)

plt.show()
```
![image](https://github.com/user-attachments/assets/29cc0357-7299-4ab0-b09f-6f11c1d231ea)

```
# 탐색적 데이터 분석(EDA), 시각화

# 좌석등급과 생존 관계
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

plt.figure(figsize=(12,8))
sns.barplot(
    data=train_df
    , x= 'Pclass'
    , y='Survived'
    , palette='coolwarm'
)

plt.show()
```
![image](https://github.com/user-attachments/assets/951ff844-e272-4806-a93e-e240f35eb4c0)

```
# 나이(연속데이터)와 생존 관계
# 히스토그램
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

plt.figure(figsize=(12,8))

# 생존 데이터관련성
sns.histplot(
    data=train_df
    , x= train_df[train_df['Survived']==1]['Age'] # 생존한 사람들의 나이
    , bins=30 # 30개 구간으로 나누고 밀도
    ,color='green'
    , kde=True # 곡선 표시 여부
    , label='Survived'
)

# 사망 데이터 관련성
sns.histplot(
    data=train_df
    , x= train_df[train_df['Survived']==0]['Age'] # 죽은 사람들의 나이
    , bins=30 # 30개 구간으로 나누고 밀도
    ,color='red'
    , kde=True # 곡선 표시 여부
    , label='Not Survived'
)

plt.legend()
plt.show()
```
![image](https://github.com/user-attachments/assets/e2b09370-247e-48ee-bcff-1303fe4dde5f)

> 어린이(10세이하)의 생존율이 높음
> 20대~40대의 성인 남성의 생존율이 낮음

---
## 연속된 데이터를 범주형 데이터 변환

왜 나이를 범주형 데이터로 변환하는가?
   - 연속형 데이터의 문제점
     - 나이는 0세부터 80세 이상 까지 연속 값을 가지고 있는데, 특정 연령대가 생존과 강한 연관성이 있더라도 머신러닝의 모델이 학습하기 어렵다.
     - 분류 모델들(결정 트리, 랜덤 포레스트, XGBoost 등)은 연속형 값보다 범주형 변수를 더 잘할 수 있다.
   - 범주형 데이터의 장점
     - 이상치 데이터에 의한 학습 문제 완화

### 범주화 방법
#### 1. 동간격 방법(Equal Interval) : 일정한 간격으로 나누는 방법 (10대, 20대, ....)
  - 장점 : 특정 구간에서 생존율이 비슷한지 비교가능
  - 단점 : 데이터의 분포와 상관 없이 균등하게 나누기 때문에, 특정 그룹이 너무 많거나 적을수 있다.

```

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

# 나이 구간을 5개로 나누는 방법(0~16,17~32,33~48,49~64, 65+)
# 0~16 -> 0
# 17~32 -> 1
# 33~48 -> 2
# 49~64 -> 3
# 65+ -> 4
age_bin=pd.cut(
    train_df['Age']
    , bins=[0,16,32,48,64,100]
    ,labels=[0,1,2,3,4]
)
age_bin

```
![image](https://github.com/user-attachments/assets/3f711538-1f0d-492d-a140-4b02b6c97ac7)

#### 2. 분위수 방법(Quantile Binning) : 데이터를 동등한 개수의 그룹으로 나누는 방법
  - 장점 : 각 그룹에 데이터가 균등하게 분포되도록 나누므로 데이터 불균형을 방지
  - 단점 : 나이의 의미적 구분이 불분명할 수 있다.
    
```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

age_bin=pd.qcut(
    train_df['Age']
    , q=10 # 10분기로 나누어로
    ,labels=[0,1,2,3,4,5,6,7,8,9]
)
age_bin
```
![image](https://github.com/user-attachments/assets/b1c78dba-f93d-40c8-97c4-6ce994336701)

```
# 해석
# 1사분위 : (최소~25%) : 0
# 2사분위 : (25%~50%) : 1
# 3사분위 : (50~75%) : 2
# 4사분위 : (75~최대) : 3


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

age_bin=pd.qcut(
    train_df['Age']
    , q=4 # 4분기로 나누어로
    ,labels=[0,1,2,3]
)
age_bin
```
![image](https://github.com/user-attachments/assets/809903e0-a5e8-402e-bab7-26e9670a384e)

#### 3. 의미 기간 그룹화(도메인 지식 활용) : 연령대를 실제 생존율 반환에 맞춰 직접 지정 ( 사회적으로 인식하는 방법)
  - 장점 : 실제 생존율 패턴과 관련이 있는 연령대를 구분 할 수 있음
  - 단점 : 특정 연령대로 데이터가 쏠릴 수 도 있어 성능이 다소 떨어 질 수 있다

 ```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

age_bin=train_df['Age'].apply(
    lambda x: 0 if x<=10 else
              1 if x <=20 else
              2 if x <=30 else
              3 if x <=40 else
              4 if x <=50 else
              5 if x <=60 else
              6 if x <=70 else
              7 if x <=80 else
              8
)
age_bin
```
![image](https://github.com/user-attachments/assets/5edebf8f-bff5-4907-9bf5-3bedd56bc542)

#### 결론 및 정리
1. 언제 범주형 변환을 사용할가?
   - 결정 트리기반 모델(Random Forest, XGBoost)에서는 범주형 변환이 유용할 수 있다.
   - 데이터가 비선형 관계일 경우, 연속형보다 범주형 변수가 성능이 더 좋을 수 있다.
   - 데이터가 적거나 이상치가 많을 때 범주화하면 안정적인 학습이 가능
2. 어떤 상황에서 어떤 방법이 좋을까?
   - 데이터가 층분히 많다면 분위수 변환(Qcut)이 일반적으로 성능이 좋다
   - 의미적인 구분이 필요하다면 도메인 지식 기반 그룹화가 더 직관적일 수 있다.
   - 기본적으로는 동간격 반환 후 다른 방식과 성능 비교하여 사용하는 것을 추천

---
## 데이터 종류

데이터는 크게 두 가지로 구분된다.
- 질적 데이터 (Qualitative Data , 범주형 데이터) : 수치화할 수 없는 데이터
- 양적 데이터 (Quantitive Data, 수치형 데이터) : 수치로 측정된 데이터

- 각각의 세부 유형과 특징
  - 질적데이터
    - 명목형(Nominal) 데이터 : 순서가 없는 데이터
      - 예시 : 성별, 혈액형, 국적 등
      - 분석 방법 : 빈도 분석, 카이제곱검정(범주형데이터 간의 관계를 결정)
    - 서열형(Ordinal) 데이터 : 순서가 있는 명목형 데이터
      - 예시 : 고객 만족도, 학점
      - 분석 방법 : 중앙값 분석, 순위, 상관 분석
  - 양적데이터
    - 이산형데이터(Discrete)
      - 예시 : 고객 방문 횟수(1,2,3..), 자녀수
      - 분석 방법 : 평균, 분산, 포아송분포
    - 연속형데이터(Continuous)
      - 예시 : 키, 몸무게, 온도
      - 분석 방법 : 평균, 표준편차(STD(Standard DB)), 정규분포

- 질적데이터(범주형 데이터)의 통계적 접근 방법
  - 질적 데이터는 숫자로 연산할 수 없기 때문에 비율, 빈도 분석이 핵심
    - 명목형 데이터
      - 데이터 간 순서가 없으며, 단순히 범주를 나타낸다
      - 빈도 분석 (Frequency Analysis) : 각 범주의 개수를 비교해서 분포를 파악
        - 예 : 성별 빈도 분석
          ```
          import numpy as np
          import pandas as pd

          data = pd.DataFrame(
              {
                  'Gender':['Male','Female','Female','Male','Male']
              }
          )
          data
          ```
          ![image](https://github.com/user-attachments/assets/a5fb52df-163b-4666-992e-2d2e77b2b4d2)

          ```
          import numpy as np
          import pandas as pd

          data = pd.DataFrame(
              {
                  'Gender':['Male','Female','Female','Male','Male']
        
              }
          )
          #빈도 분석
          print(data['Gender'].value_counts())
          ```
          ![image](https://github.com/user-attachments/assets/1d88edbf-9378-425e-8c52-975e8fef1ffa)
      - 카이저 제곱검정(Chi-Square Test)
        - 범주형 데이터 간의 관계를 검정할 때 사용
          - 예 : 성별과 생존 여부 관계 결정
          ```
          import numpy as np
          import pandas as pd
          
          from scipy.stats import chi2_contingency

          data = np.array([[50,100],[80,70]]) # [50,100] = 남성의 [생존,사망], [80,70] = 여성의 [생존,사망]
          data
          ```
          ![image](https://github.com/user-attachments/assets/e254e205-0148-4427-9d26-b69c9267734d)

          ```
          import numpy as np
          import pandas as pd

          from scipy.stats import chi2_contingency

          data = np.array([[50,100],[80,70]]) # [50,100] = 남성의 [생존,사망], [80,70] = 여성의 [생존,사망]
          chi2_contingency(data)
          ```
          ![image](https://github.com/user-attachments/assets/4294796d-530c-41f7-a23f-d79df8aa1d09)

          ```
          import numpy as np
          import pandas as pd

          from scipy.stats import chi2_contingency

          data = np.array([[50,100],[80,70]]) # [50,100] = 남성의 [생존,사망], [80,70] = 여성의 [생존,사망]
          chi2,p,_,_=chi2_contingency(data)
          print(f'P-value : {p}') # P-value< 0.05 이면 성별과 생존 여부 간에 유의마한 차이가 있다는 뜻
          ```
          ![image](https://github.com/user-attachments/assets/5adc5546-81b8-4552-a28c-1f2ae39beb85)

    - 서열형 데이터
      - 데이터 간 순서는 있지만, 간격이 일정하지 않은 데이터
        - 중앙값(Median) 분석
          - 목적 : 평균을 사용하기 어려울 때
            ```
            import numpy as np
            import pandas as pd

            data = np.array(
                [1,2,2,3,4,5] # 1 : 불만족, 5: 만족
            )

            np.median(data)
            ```
            ![image](https://github.com/user-attachments/assets/42fd197a-64fe-488c-bfe3-338492ea1819)

        - 고객만족도(서열)와 재구매(서열) 횟수의 상관관계 분석
          - 서열 데이터 간의 상관관계를 분석하는 방법
          - 스피어만 순위 상관 분석(Spearman's rank correlation analysis)
            ```
            import numpy as np
            import pandas as pd

            from scipy.stats import spearmanr
            x=[1,2,3,4,5] # 만족도
            y=[10,20,30,25,15] # 재구매횟수

            corr,p=spearmanr(x,y)
            print(f'Spearmanr Correlation: {p}')
            print(f'P-value : {p}') # P-value<0.05이면 만족도가 높을수로 재무들이 높다는 결론을 내릴수 있다
            ```
            ![image](https://github.com/user-attachments/assets/2e54f78b-101a-44db-bf12-05c0e39f7e5a)

- 양적데이터(수치 데이터)의 통계적 접근 방법
  - 양적데이터는 평균, 분산, 회귀분석 등을 활용하여 분석
    - 이산 데이터(Discrete Data)
      - 일반적으로 정수값만 가짐
        - 평균, 분산 분석
          ```
          import numpy as np
          import pandas as pd

          data = np.array(
              [
              2,3,5,7,1,0,4
              ]
          )
          print(f'평균 : {np.mean(data)}, 분산 : {np.var(data)}')
          # 분산이 크면 데이터 값들이 평균해서 많이 벗어나 있다는 의미
          # 머신러닝, 딥러닝에서 데이터가 분산이 크면 학습이 잘 안되거나, 발산이 발생할 수 있다.
          ```
          ![image](https://github.com/user-attachments/assets/1550e5a7-2145-45be-bd8f-238cb345ebe0)

        - 포아송분포(함수) : 특정 시간 동안 발생하는 이벤트 횟수 예측
          - 예 : 1시간동안 고객 방문자 수 예측
            ```
            import numpy as np
            import pandas as pd

            import scipy.stats as stats
            mu=3 # 모집단(전체데이터) 평균 방문 회수

            data = [
                0,1,2,3,4,5
            ]

            poisson_dist=stats.poisson.pmf(
                data
                ,mu
            )
            print(poisson_dist)
            ```
            ![image](https://github.com/user-attachments/assets/daa00c1f-7c81-4995-aefb-929cd05e93d0)

    - 연속형 데이터(Continuous Data)
      - 평균, 분산, 표준편차 : 크면 데이터가 평균으로부터 넓게 퍼져있는 것을 의미하여 학습이 잘 안될수도 있다.
        - 소수점 포함
            ```
            import numpy as np
            import pandas as pd

            data=np.array(
              [170,165,180,175,160] # 키 데이터
            )
            print(f'평균 : {np.mean(data)}, 표준편차 : {np.std(data)}, 분산 : {np.var(data)}')
            ```
        
            ![image](https://github.com/user-attachments/assets/942cebb0-7c3e-4954-97e0-9e9b35cdc97f)
        
      - 정규 분포 검정 : 데이터가 정규분포를 따르는지 안따르는지 여부
        - 머신러닝은 데이터가 정규분포를 따른다라는 가정하여 알고리즘들이 만들어져있다. 결국 데이터가 정규분포를 따르지 않으면 머신러닝 학습은 제대로 되지 않는다(딥러닝은 조금 틀림)
            ```
            import numpy as np
            import pandas as pd
            from scipy.stats import shapiro

            data=np.random.normal(
                0,1,100 # 평균은 0, 표준 편차는 1, 데이터 100개 생성
            )
            stat,p=shapiro(data)

            print(f'통계는 {stat}, P-value :{p}') # P-value <0.05 이면 데이터가 정규분포를 따르지 않음을 의미
            ```
            ![image](https://github.com/user-attachments/assets/94f9e1f6-f84b-4b28-854f-5d72c412afb6)

### 결론 및 정리
1. 질적 데이터(명목형, 서열형) : 카이저곱 검정, 빈도분석, 순위 상관분석 등이 활용
2. 양적 데이터(이산, 연속) : 평균, 분산, 정규성 검정, 회귀분석 등이 활용
3. 데이터 유형에 따라 적절한 통계적 접근 방법 선택하여한다.

---

## 결측치 처리

결측치(Missing Value)는 머신러닝 모델의 성능을 크게 저하시킬 수 있기 때문에, 적절한 방법으로 처리해야 한다.

- 타이타닉 데이터 결측치 확인
- 결측치 처리 방법

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

# 결측치 확인
missing_value=train_df.isnull().sum()
missing_value
```
![image](https://github.com/user-attachments/assets/4e122180-ede4-41ad-8041-2170039baefd)

결측치 시각화 하기 위해 `missingno`모듈을 설치해야한다.
```
pip install missingno
```
![image](https://github.com/user-attachments/assets/b7a4de50-c654-4d80-8f0f-2425bfcdcc8c)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
# 결측치 시각화
import missingno as msno

msno.matrix(train_df)
```
![image](https://github.com/user-attachments/assets/5691525d-6c4e-42d1-8cac-728e76d82b5f)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()

#결측치 처리 방법

# 결측치 비율
# 5% 이하 : 최대값, 평균값, 중앙값으로 대체
# 5%~30% : 특정 컬럼 그룹별 평균값, 중앙값으로 대체(예 : Pclass별 Age 평균 대체)
# 30% 이상 : 삭제하거나, 새로운 범주생성(예 : cabin의 경우 'No Cabin'으로 추가)
missing_value=train_df.isnull().sum()/train_df.count()
missing_value
```
![image](https://github.com/user-attachments/assets/341a3ce1-1ca8-4d71-bd43-f84049beaee4)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()

#결측치 처리 방법
missing_value=train_df.isnull().sum()/train_df.count()
# 나이(Age) 결측치 처리
# 방법 1 : 전체 평균으로 대체
# 장점 : 빠르고 간단한 방법
# 단점 : 나이의 분포를 왜곡할 수 있다.
# 전체 평균으로 대체 데이터는 이상치에 민감
mean_age = train_df['Age'].mean()
train_df['Age'].fillna(mean_age,inplace=False).isnull().sum()
```
![image](https://github.com/user-attachments/assets/46cc80bb-15d2-4041-a645-096473149dbf)

```
# 나이(Age) 결측치 처리
# 방법 2 : 중앙값으로 대체
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()

#결측치 처리 방법
missing_value=train_df.isnull().sum()/train_df.count()

median_age = train_df['Age'].median()
train_df['Age'].fillna(median_age,inplace=False).isnull().sum()

```
![image](https://github.com/user-attachments/assets/7cc13339-1ce3-48f1-a0eb-fc41591c3a33)

### 판다스 groupby() function
- groupby 함수는 데이터프레임에서 특정 기준으로 데이터를 그룹화하고, 그룹별 연산을 수행할 수 있는 핵심 기능
- 기분 문법
  - df.groupby('그룹핑할 컬럼').연산 식으로
    - 연산에는 sum(), mean(), count(),filter() 등이 존재

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


data = {
    "부서": ["영업", "영업", "마케팅", "마케팅", "인사", "인사", "인사"],
    "직원": ["김철수", "이영희", "박민수", "최지훈", "한지수", "정해인", "오세훈"],
    "급여": [500, 550, 620, 700, 450, 480, 500],
    "보너스": [50, 55, 60, 70, 45, 48, 50]
}
df = pd.DataFrame(data)

# 요건 : 부서별 급여의 합
df.groupby('부서').sum()['급여']
```
![image](https://github.com/user-attachments/assets/6285c2a6-8dee-488a-831c-c4b35c3c2367)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


data = {
    "부서": ["영업", "영업", "마케팅", "마케팅", "인사", "인사", "인사"],
    "직원": ["김철수", "이영희", "박민수", "최지훈", "한지수", "정해인", "오세훈"],
    "급여": [500, 550, 620, 700, 450, 480, 500],
    "보너스": [50, 55, 60, 70, 45, 48, 50]
}
df = pd.DataFrame(data)


# 그룹별 필터링(filter)
# 특정 조건을 만족하는 그룹만 선택
# 부서별 급여의 평균이 500이상인 부서와 데이터 출력
# x: Datagramegroupby
df.groupby('부서').filter(lambda x:x['급여'].mean()>500)
```
![image](https://github.com/user-attachments/assets/c67a70cb-3d91-44f0-84ba-1b8cfbf27d6b)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


data = {
    "부서": ["영업", "영업", "마케팅", "마케팅", "인사", "인사", "인사"],
    "직원": ["김철수", "이영희", "박민수", "최지훈", "한지수", "정해인", "오세훈"],
    "급여": [500, 550, 620, 700, 450, 480, 500],
    "보너스": [50, 55, 60, 70, 45, 48, 50]
}
df = pd.DataFrame(data)

# 그룹별 변화(transform())
df['급여평균']=df.groupby('부서')['급여'].transform('mean')
df
```
![image](https://github.com/user-attachments/assets/90e461de-8d32-4130-86e4-8716f2229aeb)

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


data = {
    "부서": ["영업", "영업", "마케팅", "마케팅", "인사", "인사", "인사"],
    "직원": ["김철수", "이영희", "박민수", "최지훈", "한지수", "정해인", "오세훈"],
    "급여": [500, 550, 620, 700, 450, 480, 500],
    "보너스": [50, 55, 60, 70, 45, 48, 50]
}
df = pd.DataFrame(data)

# 그룹별 사용자 정의 함수 적용(apply())
# 요건 : 부서별 최대 급여와 최소 급여의 차이

df.groupby('부서')['급여'].apply(lambda x:x.max()-x.min())
```
![image](https://github.com/user-attachments/assets/267d312f-fd6c-47ec-b599-a20a752d74e8)

```
# 나이(Age) 결측치 처리
# 방법 3 : Pclass 칼럼별 평균 나이를 구하고 대체

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법

train_age=train_df.groupby('Pclass')['Age'].transform(lambda x:x.fillna(x.mean()))
train_age
```
![image](https://github.com/user-attachments/assets/797e7a4c-061d-4552-ab5b-5c0f1bcd9e92)

```
# 나이(Age) 결측치 처리
# 방법 3 : Pclass 칼럼별 평균 나이를 구하고 대체

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법

train_age=train_df.groupby('Pclass')['Age'].transform(lambda x:x.fillna(x.mean()))
train_age.isnull().sum()
```
![image](https://github.com/user-attachments/assets/9dfa3225-1ab5-41a8-9c9a-6d4af8d601ec)

```
# 나이(Age) 결측치 처리
# 방법 4 : 머신러닝 알고리즘을 이용해서 결측치 값을 예측하고 대체

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법
# 나이를 예측하는 모델 만들어서 결측값을 채울 수 있다.
# RandomForest(분류,회귀(나이 : 연속값))
# 나이가 연속값이어서 회귀 모델도 필요

from sklearn.ensemble import RandomForestRegressor

# 나이를 예측에 필요한 컬럼(변수, 피쳐) 선택
age_data=train_df[['Age','Pclass','SibSp','Parch','Fare']]
age_data
```
![image](https://github.com/user-attachments/assets/05906b4f-1e3b-4309-8e22-159ff4ff9c57)

```
# 나이(Age) 결측치 처리
# 방법 4 : 머신러닝 알고리즘을 이용해서 결측치 값을 예측하고 대체

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법
# 나이를 예측하는 모델 만들어서 결측값을 채울 수 있다.
# RandomForest(분류,회귀(나이 : 연속값))
# 나이가 연속값이어서 회귀 모델도 필요

from sklearn.ensemble import RandomForestRegressor

# 나이를 예측에 필요한 컬럼(변수, 피쳐) 선택
age_data=train_df[['Age','Pclass','SibSp','Parch','Fare']]

print(f'전체 데이터 shape : {train_df.shape}')
# 결측치가 없는 행 : 학습 데이터로 사용 <= 결측치 행 삭제해서 추출 : dropna()
train_no_missing=age_data.dropna()
print(f'결측치가 없는 데이터 shape : {train_no_missing.shape}')

```
![image](https://github.com/user-attachments/assets/6da315b4-1d77-4416-8b46-95802ef9667e)

```
# 나이(Age) 결측치 처리
# 방법 4 : 머신러닝 알고리즘을 이용해서 결측치 값을 예측하고 대체

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법
# 나이를 예측하는 모델 만들어서 결측값을 채울 수 있다.
# RandomForest(분류,회귀(나이 : 연속값))
# 나이가 연속값이어서 회귀 모델도 필요

from sklearn.ensemble import RandomForestRegressor

# 나이를 예측에 필요한 컬럼(변수, 피쳐) 선택
age_data=train_df[['Age','Pclass','SibSp','Parch','Fare']]

# print(f'전체 데이터 shape : {train_df.shape}')
# 결측치가 없는 행 : 학습 데이터로 사용 <= 결측치 행 삭제해서 추출 : dropna()
train_no_missing=age_data.dropna()
# print(f'결측치가 없는 데이터 shape : {train_no_missing.shape}')
# 결측치가 있는 행 : # 결측치가 있는 행 : 예측 나이를 추출
age_data[age_data['Age'].isnull()]
```
![image](https://github.com/user-attachments/assets/db720efd-d4c9-420c-bc51-aa8f64be1c38)

```
# 나이(Age) 결측치 처리
# 방법 4 : 머신러닝 알고리즘을 이용해서 결측치 값을 예측하고 대체

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법
# 나이를 예측하는 모델 만들어서 결측값을 채울 수 있다.
# RandomForest(분류,회귀(나이 : 연속값))
# 나이가 연속값이어서 회귀 모델도 필요

from sklearn.ensemble import RandomForestRegressor

# 나이를 예측에 필요한 컬럼(변수, 피쳐) 선택
age_data=train_df[['Age','Pclass','SibSp','Parch','Fare']]
# print(f'전체 데이터 shape : {train_df.shape}')

# 결측치가 없는 행 : 학습 데이터로 사용 <= 결측치 행 삭제해서 추출 : dropna()
train_no_missing=age_data.dropna()
# print(f'결측치가 없는 데이터 shape : {train_no_missing.shape}')

# 결측치가 있는 행 : # 결측치가 있는 행 : 예측 나이를 추출
# 결측치가 있는 행을 찾자: Boolean <= age_data['Age'].isnull()
age_data[age_data['Age'].isnull()].drop('Age',axis=1)
```
![image](https://github.com/user-attachments/assets/fe6bbec6-5e99-40a3-af9a-bd61327b23b8)

```
# 나이(Age) 결측치 처리
# 방법 4 : 머신러닝 알고리즘을 이용해서 결측치 값을 예측하고 대체

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법
# 나이를 예측하는 모델 만들어서 결측값을 채울 수 있다.
# RandomForest(분류,회귀(나이 : 연속값))
# 나이가 연속값이어서 회귀 모델도 필요

from sklearn.ensemble import RandomForestRegressor

# 나이를 예측에 필요한 컬럼(변수, 피쳐) 선택
age_data=train_df[['Age','Pclass','SibSp','Parch','Fare']]
print(f'전체 데이터 shape : {train_df.shape}')

# 결측치가 없는 행 : 학습 데이터로 사용 <= 결측치 행 삭제해서 추출 : dropna()
train_no_missing=age_data.dropna()
print(f'결측치가 없는 데이터 shape : {train_no_missing.shape}')

# 결측치가 있는 행 : # 결측치가 있는 행 : 예측 나이를 추출
# 결측치가 있는 행을 찾자: Boolean <= age_data['Age'].isnull()
train_missing=age_data[age_data['Age'].isnull()].drop('Age',axis=1)
print(f'결측치가 있는 데이터 shape : {train_missing.shape}')
```
![image](https://github.com/user-attachments/assets/f8b2e54f-5596-408c-a925-0b34845df31b)

```
# 나이(Age) 결측치 처리
# 방법 4 : 머신러닝 알고리즘을 이용해서 결측치 값을 예측하고 대체

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법
# 나이를 예측하는 모델 만들어서 결측값을 채울 수 있다.
# RandomForest(분류,회귀(나이 : 연속값))
# 나이가 연속값이어서 회귀 모델도 필요

from sklearn.ensemble import RandomForestRegressor

# 나이를 예측에 필요한 컬럼(변수, 피쳐) 선택
age_data=train_df[['Age','Pclass','SibSp','Parch','Fare']]
# print(f'전체 데이터 shape : {train_df.shape}')

# 결측치가 없는 행 : 학습 데이터로 사용 <= 결측치 행 삭제해서 추출 : dropna()
train_no_missing=age_data.dropna()
# print(f'결측치가 없는 데이터 shape : {train_no_missing.shape}')

# 결측치가 있는 행 : # 결측치가 있는 행 : 예측 나이를 추출
# 결측치가 있는 행을 찾자: Boolean <= age_data['Age'].isnull()
train_missing=age_data[age_data['Age'].isnull()].drop('Age',axis=1)
# print(f'결측치가 있는 데이터 shape : {train_missing.shape}')

# 결측치가 없는 행들의 데이터를 머신러닝을 통해서 결측치가 있는 데이터의 나이를 추측하여 대입

# 학습데이터를 데이터와 label(답)으로  분리 : 데이터(4개 칼럼), 답 (나이)
X_train=train_no_missing.drop('Age',axis=1,inplace=False) # 삭제하고 나머지 반환 (원본에서는 삭제 안됨)

# 답(나이 컬럼) 추출
y_train=train_no_missing['Age']

# 모델 생성
model=RandomForestRegressor(n_estimators=100,random_state=42)

# 학습 끝나면 모델(오차가 최소가 되는 식)이 완성
model.fit(X_train,y_train)

```
![image](https://github.com/user-attachments/assets/48b9ce79-69d4-40bb-802b-11598ae2b2b4)

```
# 나이(Age) 결측치 처리
# 방법 4 : 머신러닝 알고리즘을 이용해서 결측치 값을 예측하고 대체

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법
# 나이를 예측하는 모델 만들어서 결측값을 채울 수 있다.
# RandomForest(분류,회귀(나이 : 연속값))
# 나이가 연속값이어서 회귀 모델도 필요

from sklearn.ensemble import RandomForestRegressor

# 나이를 예측에 필요한 컬럼(변수, 피쳐) 선택
age_data=train_df[['Age','Pclass','SibSp','Parch','Fare']]
# print(f'전체 데이터 shape : {train_df.shape}')

# 결측치가 없는 행 : 학습 데이터로 사용 <= 결측치 행 삭제해서 추출 : dropna()
train_no_missing=age_data.dropna()
# print(f'결측치가 없는 데이터 shape : {train_no_missing.shape}')

# 결측치가 있는 행 : # 결측치가 있는 행 : 예측 나이를 추출
# 결측치가 있는 행을 찾자: Boolean <= age_data['Age'].isnull()
train_missing=age_data[age_data['Age'].isnull()].drop('Age',axis=1)
# print(f'결측치가 있는 데이터 shape : {train_missing.shape}')

# 결측치가 없는 행들의 데이터를 머신러닝을 통해서 결측치가 있는 데이터의 나이를 추측하여 대입

# 학습데이터를 데이터와 label(답)으로  분리 : 데이터(4개 칼럼), 답 (나이)
X_train=train_no_missing.drop('Age',axis=1,inplace=False) # 삭제하고 나머지 반환 (원본에서는 삭제 안됨)

# 답(나이 컬럼) 추출
y_train=train_no_missing['Age']

# 모델 생성
model=RandomForestRegressor(n_estimators=100,random_state=42)

# 학습 끝나면 모델(오차가 최소가 되는 식)이 완성
model.fit(X_train,y_train)

# 나이의 결측치를 채울 예측 나이 추출 및 대체
# 예측
# model.predict(train_missing) => 예측 나이가 추출
train_df.loc[train_df['Age'].isnull(),'Age']=model.predict(train_missing)

train_df['Age'].isnull().sum()
```
![image](https://github.com/user-attachments/assets/58fa9507-2a0e-4dd4-a6c4-e83146db3eac)

```
# 나이(Age) 결측치 처리
# 방법 4 : 머신러닝 알고리즘을 이용해서 결측치 값을 예측하고 대체

# 장점 : 데이터 패턴을 학습하여 더 정밀한 값으로 대체할 수 있어 모델의 성능 향상 기대 가능
# 단정 : 시간이 걸린다, 성능 향상을 기대하면 안된다.

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

train_df=pd.read_csv(
    './data/titanic/train.csv'
    ,encoding='utf-8'
)

missing_value=train_df.isnull().sum()
missing_value_percent=train_df.isnull().sum()/train_df.count()

#결측치 처리 방법
# 나이를 예측하는 모델 만들어서 결측값을 채울 수 있다.
# RandomForest(분류,회귀(나이 : 연속값))
# 나이가 연속값이어서 회귀 모델도 필요

from sklearn.ensemble import RandomForestRegressor

# 나이를 예측에 필요한 컬럼(변수, 피쳐) 선택
age_data=train_df[['Age','Pclass','SibSp','Parch','Fare']]
# print(f'전체 데이터 shape : {train_df.shape}')

# 결측치가 없는 행 : 학습 데이터로 사용 <= 결측치 행 삭제해서 추출 : dropna()
train_no_missing=age_data.dropna()
# print(f'결측치가 없는 데이터 shape : {train_no_missing.shape}')

# 결측치가 있는 행 : # 결측치가 있는 행 : 예측 나이를 추출
# 결측치가 있는 행을 찾자: Boolean <= age_data['Age'].isnull()
train_missing=age_data[age_data['Age'].isnull()].drop('Age',axis=1)
# print(f'결측치가 있는 데이터 shape : {train_missing.shape}')

# 결측치가 없는 행들의 데이터를 머신러닝을 통해서 결측치가 있는 데이터의 나이를 추측하여 대입

# 학습데이터를 데이터와 label(답)으로  분리 : 데이터(4개 칼럼), 답 (나이)
X_train=train_no_missing.drop('Age',axis=1,inplace=False) # 삭제하고 나머지 반환 (원본에서는 삭제 안됨)

# 답(나이 컬럼) 추출
y_train=train_no_missing['Age']

# 모델 생성
model=RandomForestRegressor(n_estimators=100,random_state=42)

# 학습 끝나면 모델(오차가 최소가 되는 식)이 완성
model.fit(X_train,y_train)

# 나이의 결측치를 채울 예측 나이 추출 및 대체
# 예측
# model.predict(train_missing) => 예측 나이가 추출
train_df.loc[train_df['Age'].isnull(),'Age']=model.predict(train_missing)

import missingno as msno

msno.matrix(train_df)
```
![image](https://github.com/user-attachments/assets/3cb4ace9-9447-4e90-9000-d02e1bff706b)
